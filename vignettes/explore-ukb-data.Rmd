---
title: "Explore UK Biobank data"
author: "Ken B. Hanscombe"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<br>

After downloading and decrypting your UK Biobank (UKB) data with the supplied [UKB programs](http://biobank.ctsu.ox.ac.uk/crystal/docs/UsingUKBData.pdf), you have multiple files that need to be brought together to give you a tidy dataset to explore. The data file has column names that are the field codes from the UKB data showcase. `ukbtools` provides tools to tidy up the naming of the variables and perform exploratory analysis. 

<br>
<br>


## 1. Preparing a UKB fileset

Download^ยง^ then decrypt your data and create a UKB fileset (.tab, .r, .html):

```{bash, eval = FALSE}
ukb_unpack ukbxxxx.enc key
ukb_conv ukbxxxx.enc_ukb r
ukb_conv ukbxxxx.enc_ukb docs

```


`ukb_unpack` decrypts your downloaded `ukbxxxx.enc` file, outputting a `ukbxxxx.enc_ukb` file. `ukb_conv` with the `r` flag converts the decrypted data to a tab-delimited file `ukbxxxx.tab` and an R script `ukbxxxx.r` that reads the tab file. The `docs` flag creates an html file containing a field-code-to-description table (among others).

<br>

^ยง^ Full details of the data download and decrypt process are given in the [Using UK Biobank Data](http://biobank.ctsu.ox.ac.uk/crystal/docs/UsingUKBData.pdf) documentation .

<br>
<br>


## 2. Making a dataset

The function `ukb_df()` takes two arguments, the stem of your fileset and the path, and returns a dataframe with usable column names. 


```{r, eval = FALSE}

my_ukb_data <- ukb_df("ukbxxxx")

```


You can also specify the path to your fileset if it is not in the current directory. For example, if your fileset is in a subdirectory of the working directory called `data`


```{r, eval = FALSE}

my_ukb_data <- ukb_df("ukbxxxx", path = "/full/path/to/my/data")

```


<br>

__Note:__ You can move the three files in your fileset after creating them with `ukb_conv`, but they should be kept together. `ukb_df()` automatically updates the read call in the R source file to point to the correct directory (the current directly by default, or the directory specified by `path`).

<br>
<br>

#### 2.1 Multiple downloads

If you have multiple UKB downloads, tidy then merge them.

```{r eval = FALSE}

ukbxxxx_data <- ukb_df("ukbxxxx")
ukbyyyy_data <- ukb_df("ukbyyyy")
ukbzzzz_data <- ukb_df("ukbzzzz")

my_ukb_data <- plyr::join_all(
  list(
    ukbxxxx_data,
    ukbyyyy_data,
    ukbzzzz_data),
  by = "eid",
  type = "full")

```

<br>

__Note:__ You will have at least one variable duplicated in the different downloads, the unique individual identifier `eid`. Counting the repeated variables (and the number of repeats of each) can give you a sense of the expected number of variables in your merged dataset.

```{r, eval = FALSE}

ukb_names <- c(
  names(ukbxxxx_data),
  names(ukbyyyy_data),
  names(ukbzzzz_data)
)
count_ukb_names <- data.frame(table(ukb_names))
dim(count_ukb_names[count_names$Freq > 1, ])

```

<br>
<br>


## 3. Retreiving ICD diagnoses


To retrieve the full diagnosis of an individual

```{r, eval = FALSE}

icd_diagnosis(my_ukb_data, id = "0000000", icd.version = 10)

```

<br>
<br>

To retrieve the "meaning" of an ICD code use `icd_code`. (You can also look up multiple codes by concatenating them.)

```{r, eval = FALSE}

icd_code(icd.code = "H282", icd.version = 10)

```

The full ICD "code-meaning" tables are available as datasets (`icd9codes`, `icd10codes`).

<br>
<br>

To see the disease "blocks" that correspond to "chapters" in ICD-9 or ICD-10, `icd_chapter` takes the relevant ICD revision (or version) number

```{r, eval = FALSE}

icd_chapter(icd.version = 10)

```

`icd_chapter` prints to screen the required table. These are also available for query as datasets (`icd9chapters`, `icd10chapters`)

<br>
<br>


## 4. Exploring a UKB sample subset

As an exploratory step you might want to look at the demographics of a particular subset of the UKB sample relative to a reference sample. For example, the subsample with data on your variable of interest compared to those without data (i.e. `NA`). `ukb_context` takes either a comparison variable (`comparison.var`) or a logical vector (`sample.ref`) to define a reference and comparison sample.

```{r, eval = FALSE}

ukb_context(
  my_ukb_data,
  age.var = "year_of_birth_0_0",
  sample.ref = sample(c(T,F), nrow(my_ukb_data), replace = TRUE)
  )

```


<br>
<br>


## 5. Genetic metadata

If you are doing any downstream genetic analyses, you will need the genetic metadata (which should be in you phenotype dataset). Detailed information is available on UKB [genotyping and quality control](http://www.ukbiobank.ac.uk/wp-content/uploads/2014/04/UKBiobank_genotyping_QC_documentation-web.pdf) and [imputation and association](http://www.ukbiobank.ac.uk/wp-content/uploads/2014/04/imputation_documentation_May2015.pdf).

<br>
<br>

You can collect the genetic metadata (including recommended exclusions, genetic sex, genetic ethnicity, chip, etc.), and principal components with

```{r, eval = FALSE}

my_gen_meta <- ukb_meta(my_ukb_data)
my_gen_pcs <- ukb_gen_pcs(my_ukb_data)

```

<br>
<br>

A list of IDs for recommended exclusions and heterozygosity outliers (+/- 3*SD) can be retreived

```{r, eval = FALSE}

ukb_gen_excl(my_ukb_data)
ukb_gen_het(my_ukb_data)

```


<br>
<br>

`ukb_gen_rel` returns a dataframe with `id`, `pair` (a numeric identifier for related pairs), and `kinship` (kinship coefficient)

```{r, eval = FALSE}

my_gen_rel <- ukb_gen_rel(my_ukb_data)

```


<br>
<br>
